# 1.OSI与TCP/IP

网络的7层架构（从上至下）：

1. 应用层：终端应用
2. 表示层：对数据进行解密加密、压缩与解压缩等
3. 会话层：不同机器通过传输层建立传输的通道
4. 传输层：采用TCP/UDP等协议对下层接收到的数据进行分段传输，这层数据叫做段
5. 网络层：将ip地址进行封装与解封装，这层数据叫做数据包
6. 数据链路层：将mac地址进行封装与解封装，这层数据叫做帧
7. 物理层：将0和1等转化为电流的强弱，这层数据叫做比特

TCP/IP协议族：

从协议分层模型来讲，由四个层次组成（从上至下）：

1. 应用层：应用层包含所有的高层协议，比如FTP（文件传输协议）、HTTP（超文本传输协议）、SMTP（电子邮件传输协议）、DNS（域名服务）等
2. 传输层：在两个机器之间进行传输，提供两种协议，TCP（传输控制协议）、UDP（用户数据报协议）
3. 网络层：采用IP协议，使主机可以把分组发往任何网络，并使分组独立的发往目标
4. 网络接口层：主机必须使用某种协议与网络相连

综合上面两种优点，采取五层协议的结构（从上至下）：

1. 应用层：定义应用进程间的通信和交互的规则，数据单元称为报文
2. 传输层：负责向两台主机进程之间提供数据传输服务
3. 网络层：采用IP协议，选择合适的网间路由和交换结点
4. 数据链路层：将网络层交下来的数据组装成帧
5. 物理层：实现相邻结点间比特流的透明传送

# 2.TCP三次握手和四次挥手

## 2.1数据包的说明

1. 16位源端口号：2个字节

2. 16位目的端口号：这两个值加上IP报头中的源主机IP地址和目的主机IP地址唯一确定一个TCP连接

3. 32位序号seq：TCP连接中传送的字节流中的每个字节都按顺序编号，比如一段报文的序号字段值是101，携带的数据有100个字段，下一个报文段的序号就从201开始

4. 32位确认号ack：期望收到对方下一个报文的序号，比如B收到A发来的序号201开始的报文，长度为200，因此B期望收到A的下一个数据序号就是401，就把确认号置位701

5. 4位TCP报头长度：指明数据从哪里开始

6. 6位保留位：保留给将来使用，目前必须置为0

7. 6位控制位，分别为：
   URG：为1表明紧急指针字段有效，告诉系统此报文段中有紧急数据

   ACK：为1表示确认号字段有效，在连接建立后所有报文的传输都必须把ACK置为1

   PSH：为1表示是带有PUSH标志的数据，告诉接收方必须尽快把这个报文段交给应用层而不用等待缓冲区装满

   RST：当RST=1，表明TCP连接中出现严重差错，必须释放连接，重新建立连接

   SYN：同步序号，为1表示连接请求，SYN=1，ACK=0表明是连接请求报文，如果同意连接，响应报文中应该使SYN=1，ACK=1

   FIN：用于释放连接，为1表示发送方已经没有数据发送了，要求释放连接

8. 16位窗口大小：通知接收方需要有多大的空间来接收该报文

9. 16位检验和：检验首部和数据两部分，发送端计算和存储，接收端进行验证

10. 16位紧急指针：URG为1时有效

11. 选项：定义一些其他的可选的参数

    ![image-20200426224951110](C:\Users\11579\AppData\Roaming\Typora\typora-user-images\image-20200426224951110.png)

## 2.2三次握手

第一次握手：主机A发送SYN=1，选择一个初始序列号seq=x ，主机B根据SYN=1知道，A请求建立连接

第二次握手：主机B收到请求后如果同意连接向A发送确认报文，确认报文中ACK=1，SYN=1，确认号是ack=x+1，同时自己初始化一个序列号seq=y

第三次握手：主机A收到确认后，还要向主机B给出确认，确认报文的ACK=1，seq=x+1，ack=y+1，主机B收到后确认则连接建立成功

## 2.3四次挥手

第一次挥手：客户端A发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认，FIN=1，序列化seq=u

第二次挥手：服务器收到这个FIN，返回一个ACK=1，返回ack=u+1，seq=v，此时服务端进入close-wait（关闭等待）状态，出于半关闭状态，客户端不能发送数据给服务端，但是服务端可以发送给客户端，

第三次挥手：客户端收到服务端的确认请求后，进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，当服务器将最后的数据发送完毕后，向客户端发送连接释放报文，FIN=1，ack=u+1，此时服务器可能又发送了一些数据，所以seq假设为seq=w，此时服务器进入了LAST-ACK（最后确认）状态，等待客户端确认

第四次挥手：客户端收到服务端的连接释放报文后，发出确认，ACK=1，ack=w+1，自己的序列号seq=u+1，ack=w+1，此时客户端进入TIME-WAIT（时间等待）状态，此时连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态，服务器只要收到了客户端发出的确认，立刻进入CLOSED状态

# 3.TCP、UDP协议的区别

TCP：一般用于即时通信

1.提供面向连接的服务，传送数据之前必须先建立连接

2.传输可靠

3.以字节流形式传输

4.传输效率低

5.所需资源多

UDP：一般用于文件传输、发送接收邮件、远程登录等

1.传送数据之前不需要建立连接

2.传输不可靠

3.以数据报文段形式传输

4.传输速率高

5.所需资源少

# 4.TCP协议保证可靠传输

1. 应用数据被切割成TCP认为最适合发送的数据块
2. TCP给发送的每一个包进行编号，接收方对数据包进行排序，将有序数据发送给应用层
3. 校验和：TCP保持首部和数据的校验和，如果收到段的检验和有差错，TCP将丢弃这个报文段并且不确认收到此报文段
4. TCP接收端会丢弃重复数据
5. 流量控制：TCP连接的每一方都有固定大小的缓冲空间，接收端只允许发送端发送接收端的缓冲区能容纳的数据，当接收方来不及处理发送方的数据时，能提示发送方降低发送的速率，防止包丢失（利用滑动窗口实现流量控制）
6. 拥塞控制：当网络拥塞时，减少数据的发送
7. ARQ协议：为了实现可靠传输，原理是每发完一个分组就停止发送，等待对方确认，收到确认后再发送下一个分组
8. 超时重传：TCP发出一个段后，会启动一个定时器，如果在该时间内没有收到目的端确认，会重发这个报文段

# 5.ARQ协议

Automatic Repeat-reQuest，自动重传请求，通过使用确认和超时两个机制，在不可靠服务的基础上实现可靠的信息传输，如果发送方在发送后一段时间之内没有收到确认帧，将会重新发送，ARQ包括停止等待ARQ协议和连续ARQ协议

## 停止等待ARQ协议

- 每发完一个分组就停止发送，等待对方确认，如果过了一段时间还是没有收到ACK确认，说明没有发送成功，需要重新发送，直到收到确认后再发送下一个分组
- 在该协议中，入股接收方收到重复分组，就丢弃该分组，但同时还要发送确认

优点：简单

缺点：信道利用率低，等待时间长

## 连续ARQ协议

发送方维持一个发送窗口，位于发送窗口的分组可以连续发送出去，不需要等待对方确认，接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组已经正确收到了

优点：信道利用率高

缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息，比如发了5条消息，第三条丢失，接收方只能对前2个发送确认，发送方不知道后3个分组的下落，只能全部重传一次

# 6.流量控制

TCP利用滑动窗口来实现流量控制，接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送效率，如果将窗口字段置为0，则发送方将不能发送数据

# 7.拥塞控制

拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器以及与降低网络传输性能有关的所有因素，而流量控制往往是点对点通信量的控制。

为了进行拥塞控制，TCP发送方要维持一个拥塞窗口的状态变量，拥塞控制窗口的大小取决于网络的拥塞程度，并且能够动态变化，发送方的发送窗口取拥塞窗口和接收方的接收窗口中较小的一个。

TCP拥塞控制采用了四种算法：

- 慢开始：当主机开始发送数据时，由小到大逐渐增大发送窗口，初始值为1，每经过一个传播轮次，加倍
- 拥塞避免：让拥塞窗口缓慢增大，每经过一个往返时间就把发送的cwnd加1
- 快重传和快恢复：如果接收机接收到一个不按顺序的数据段，会立即给发送机发送一个重复确认，如果发送机接收到三个重复确认，则会假定数据段丢失了，并立即重传

# 8.输入url地址到显示主页的过程

1. DNS解析：将域名等解析成ip地址
2. 封装HTTP请求数据包：将以上部分结合本机的信息，封装成一个HTTP请求数据包
3. 封装成TCP包并且建立连接
4. 客户机发送请求命令：建立连接后，客户机发送一个请求给服务器
5. 服务器响应：服务器接收到请求后，给予相应的响应信息
6. 服务器关闭TCP连接：一般情况下，一旦web防御武器向浏览器发送了请求数据，它就要关闭TCP连接，如果在头信息加入了Connection:keep-alive，在发送后仍然保持打开状态

# 9.状态码

|      |       类别       |          原因短语          |
| :--: | :--------------: | :------------------------: |
| 1XX  |   信息性状态码   |     接收的请求正在处理     |
| 2XX  |    成功状态码    |      请求正常处理完毕      |
| 3XX  |   重定向状态码   | 需要进行附加操作以完成请求 |
| 4XX  | 客户端错误状态码 |     服务器无法处理请求     |
| 5XX  | 服务端错误状态码 |     服务器处理请求出错     |

100：继续

200：成功

204：无内容

301：永久移动

302：临时移动

304：未修改

400：错误请求

401：未授权

403：禁止访问

404：未找到

422：请求格式正确，但有语义错误

500：内部服务器错误

# 10.各种协议与HTTP协议间的关系

HTTP协议：

​	客户端：生成针对目标web服务器的HTTP请求报文

​	服务端：对web服务器请求的内容进行处理

TCP协议：

​	客户端：为了方便通信，将HTTP请求报文分割成报文段

​	服务端：重组到达的报文段

IP协议：搜索对方地址，一边中转一边传送

# 11.HTTP长连接、短连接

短连接：客户端和服务器每进行一次HTTP操作，就建立一次连接（HTTP/1.0默认使用）

长连接：HTTP/1.1起默认使用，会在响应头加入Connection:keep-alive，可以设置一个保持时间













