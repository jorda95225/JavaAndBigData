# 1.操作系统概念

1. 操作系统是一个管理计算机硬件和软件资源的程序，是计算机系统的内核与基石
2. 操作系统为用户提供一个和计算机硬件交互的操作界面
3. 操作系统本质上是一种运行在计算机上的软件程序
4. 操作系统分为外壳与内核（内核负责管理系统的进程、内存、文件、网络等，决定系统的性能和稳定性）

# 2.系统调用

用户态：用户态运行的进程可以直接读取用户程序的数据

系统态：系统态运行的进程几乎可以访问计算机的任何资源，不受限制

在我们运行的用户程序中，凡是与系统态级别的资源有关的操作，都必须通过系统调用的方式向操作系统提出请求，并由操作系统代为完成。

按照功能分为以下几类：

- 设备管理，完成设备的请求与释放，启动等
- 文件管理，完成文件读写、创建删除等
- 进程控制，完成进程创建、撤销、阻塞、唤醒等
- 进程通信，完成进程间的消息传递等
- 内存管理：完成内存分配、回收等

# 3.进程和线程

线程是进程划分成的更小的运行单位，一个进程在运行过程中可以产生多个线程，各进程是独立的，各线程则不一定，同一进程中的线程可能会相互影响，线程执行开销小，但不利于管理，进程则相反

# 4.进程状态

- 创建状态（new）
- 就绪状态（ready）
- 运行状态（running）
- 阻塞状态（waiting）
- 结束状态（terminated）

# 5.进程通信方式

1. 管道/匿名管道（Pipes）：用于具有亲缘关系的父子进程或兄弟进程之间通信
2. 有名管道（Names Pipes）：可以实现本机任意两个进程通信，遵循先进先出，以磁盘文件的方式存在
3. 信号（Signal）：通知接收进程某个事件已经发生
4. 消息队列（Message Queuing）：消息的链表，存放在内核中，只有在内核重启时或者显式地删除一个消息队列时才会被真正删除，消息队列克服了信号承载信息量少，管道只能承载无格式字符流以及缓冲区大小受限等缺点
5. 信号量（Semaphores）：是一个计数器，用于多进程对共享数据的访问，主要用于解决与同步相关的问题并避免竞争
6. 共享内存（Shared memory）：使多个进程可以访问同一块内存，不同进程可以及时看到其他进程对共享内存中数据的更新，这种方式需要一些同步操作，比如互斥锁和信号量等，可以说是最有用的进程间通信方式
7. 套接字（Sockets）：主要用于客户端和服务器之间通过网络通信，套接字是支持TCP/IP的网络通信的基本操作单元

# 6.线程同步方式

1. 互斥量（Mutex）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如synchronized和各种lock
2. 信号量（Semphares）：运行同一时刻多个进程访问同一资源，但要控制同时访问的最大线程数量
3. 事件（Event）：通过通知操作的方式保持多线程同步

# 7.进程调度算法

- 先到先服务（FCFS）调度算法：从就绪队列中选择一个最先进入的进程为之分配资源，让它立即执行并且一直执行到完成或者发生某事件被阻塞放弃占用CPU时再重新调度
- 短作业优先（SJF）调度算法：从就绪队列中选择一个估计运行时间最短的进程为之分配资源，让它立即执行并且一直执行到完成或者发生某事件被阻塞放弃占用CPU时再重新调度
- 时间片轮转调度算法：每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间
- 多级反馈队列调度算法：既能使高优先级的作业得到响应又能使短作业迅速完成，目前被公认的一种较好的进程调度算法
- 优先级调度：按进程优先级分配

多级反馈队列调度算法：

按照先来先服务原则排序，设置N个就绪队列为Q1，Q2...QN，每个队列中都可以放很多作业；
为这N个就绪队列赋予不同的优先级，第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低；
设置每个就绪队列的时间片，优先权越高，算法赋予队列的时间片越小。时间片大小的设定按照实际作业（进程）的需要调整；
进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。
首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。
对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了时间片为N的时间后，若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。
在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业即抢占式调度CPU。

# 8.内存管理介绍

内存管理主要负责内存的分配与回收，还有地址转换，将逻辑地址转换成相应的物理地址

# 9.内存管理机制

简单分为**连续分配管理方式**和**非连续分配管理方式**，前者为一个用户程序分配一个连续的内存空间，如块式管理，后者允许一个程序使用的内存分布在离散的内存中，如页式管理和段式管理。

1. 块式管理：将内存分为几个固定大小的块，每块中只包含一个进程，如果程序运行只需要很小的空间，分配的这块内存很大一部分就被浪费了
2. 页式管理：把内存分为大小相等 且固定的一页一页的形式，页比较小，相比于上者划分的更小，提高了内存利用率，通过页表对应逻辑地址和物理地址
3. 段式管理：页式管理虽然提高了内存利用率，但是其中的页实际上并无任何意义，段式管理将内存分为一段段的，每段的空间比一页的空间小很多，段是有实际意义的，每个段定义了一组逻辑信息，比如主程序段main、子程序段x、数据段d以及栈段s等，通过段表对应逻辑地址和物理地址
4. 段页式管理：结合段式管理和页式管理优点，先把内存分为若干段，每个段又分成若干页，段与段之间以及段的内部都是离散的

# 10.快表和多级页表

快表：

快表是为了解决虚拟地址到物理地址的转换速度，可以理解为一种特殊的高速缓存存储器，其中的内容是页表的一部分或者全部内容，作用与页表相似，但是提高了访问速率，由于采用页表做地址转换，读写内存时CPU要访问两次主存，有了快表有时只需要访问一次高速缓存存储器，一次主存，可以加速查找并提高指令执行速度。

使用快表之后地址转换流程：

1. 根据虚拟地址中的页号查快表
2. 如果该页在快表中，直接从快表中读取相应的物理地址
3. 如果不在，就访问内存中的页表，得到物理地址，同时将页表中的该映射表项添加到快表中
4. 当快表填满后，又要登记新页，按照一定的淘汰策略淘汰掉快表中的一页

多级页表：

主要是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中，属于时间换空间的场景

# 11.分页机制和分段机制比较

共同点：都是为了提高内存利用率，都是离散存储的

区别：页的大小是固定的，由操作系统决定，段的大小不固定，由当前运行程序决定，分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段等

# 12.逻辑地址和物理地址

逻辑地址由操作系统决定，即我们平常说的内存地址，物理地址指的是真实物理内存中的地址，即内存地址寄存器中的地址，物理地址是内存单元真正的地址

# 13.CPU寻址和虚拟地址空间

现代处理器使用虚拟寻址的寻址方式，使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，才能访问到真实的物理内存，实际上完成虚拟地址转换为物理地址转换的硬件是CPU中的内存管理单元（Memory Management Unit）

![image-20200429225049965](C:\Users\11579\AppData\Roaming\Typora\typora-user-images\image-20200429225049965.png)

为什么要有虚拟地址空间：

没有虚拟地址空间的话，程序直接访问操作物理内存，这样存在的问题有：

1. 用户程序可以访问任意内存，寻找内存的每个字节，容易破坏操作系统，造成操作系统崩溃
2. 想同时运行多个程序特别困难，可能会覆盖掉

通过虚拟地址访问内存的优势：

- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区
- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区，当物理内存的供应量变小时，内存管理器会将物理内存页（通常为4KB）保存到磁盘文件，数据或代码页会根据需要再物理内存与磁盘之间移动
- 不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存

# 14.虚拟内存

虚拟内存可以让程序拥有超过系统物理内存大小的可用内存空间，为每个进程提供了一个私有的、一致的地址空间，让每个进程产生了自己在独享主存的错觉，这样会有效地管理内存并减少出错

它的重要意义是定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间

# 15.局部性原理

局部性原理表现在以下两个方面：

1. 时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行，如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作
2. 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的

时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存

# 16.虚拟存储器

基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——**虚拟存储器**

# 17.虚拟内存的技术实现

虚拟内存的实现需要建立在离散分配的内存管理方式的基础上，有以下三种方式：

























